# 클린 아키텍처와 FastAPI 구현에 대한 Q&A

이 문서는 FastAPI 프로젝트를 진행하며 논의된 클린 아키텍처의 개념, 파이썬의 비동기 처리, 그리고 의존성 역전 원칙에 대한 질문과 답변을 정리한 것입니다.

## 1. 파이썬의 객체 업데이트 방식과 SQLModel

### 객체 업데이트 시 속성을 일일이 할당해야 하나요?
**배경**: 기존 코드에서는 `item.name = update.name`처럼 속성을 하나씩 수동으로 할당하고 있었습니다. 자바스크립트의 비구조화 할당(Destructuring)처럼 더 간편한 방법이 없는지 궁금해했습니다.

**해결 방안**:
파이썬, 특히 Pydantic과 SQLModel을 사용할 때는 `model_dump()`와 `sqlmodel_update()` 메서드를 활용하여 깔끔하게 처리하는 것이 권장됩니다.

1.  **데이터 추출**: `update_data = item_update.model_dump(exclude_unset=True)`
    *   `exclude_unset=True`: 클라이언트가 전송하지 않은 필드(값이 없는 필드)는 무시하고, 실제 변경 요청된 값만 딕셔너리로 추출합니다.
2.  **일괄 업데이트**: `item.sqlmodel_update(update_data)`
    *   추출된 딕셔너리 데이터를 이용해 객체의 상태를 한 번에 업데이트합니다.

## 2. 의존성 주입(DI)과 AsyncSession의 역할

### Repository 생성 시 AsyncSession이 필요한 이유와 그 의미는?
**배경**: `return PostgresItemRepository(session)` 코드에서 클래스 생성자에 `session`을 넘기는 구조와 `AsyncSession`의 필요성에 대해 질문했습니다.

**핵심 개념**:
1.  **인스턴스 생성**: `PostgresItemRepository`는 클래스(설계도)이고, 여기에 `session`이라는 재료를 넣어 실제 동작하는 객체(인스턴스)를 만들어내는 과정입니다. 생성된 리포지토리는 이 세션을 내부 상태로 보유하며 DB 통신에 사용합니다.
2.  **AsyncSession (비동기)**:
    *   **동기(Sync)**: DB 응답이 올 때까지 서버가 멈춰서 기다림 (비효율적).
    *   **비동기(Async)**: DB에 요청을 보내고 응답을 기다리는 동안, 서버가 멈추지 않고 **다른 사용자의 요청을 처리**함 (고성능).
    *   FastAPI의 성능을 극대화하기 위해 I/O 작업(DB 조회 등)에는 반드시 비동기 세션을 사용해야 합니다.

## 3. 파이썬의 비동기 처리 메커니즘

### 파이썬은 자바스크립트처럼 싱글 스레드 기반인가요?
**배경**: 자바스크립트의 싱글 스레드/이벤트 루프 모델에 익숙한 상태에서, 파이썬의 비동기 처리 방식이 이와 유사한지 궁금해했습니다.

**설명**:
네, **FastAPI(`asyncio`)의 동작 방식은 Node.js(자바스크립트)와 매우 유사합니다.**

1.  **이벤트 루프(Event Loop)**: 파이썬도 단일 스레드에서 `Event Loop`가 돌아갑니다.
2.  **동작 원리**:
    *   `await` 키워드를 만나면 실행을 잠시 멈추고 제어권을 이벤트 루프에게 넘깁니다.
    *   이벤트 루프는 그 시간에 대기 중인 다른 작업(다른 유저의 요청 등)을 처리합니다.
    *   이는 I/O 바운드 작업(DB, 네트워크)에서 효율성을 극대화하는 방식입니다.
3.  **차이점**: CPU를 많이 쓰는 작업(계산 등)을 할 때는 파이썬의 경우 멀티프로세싱 등을 활용해야 하지만, 웹 서버의 주 업무인 I/O 처리에 있어서는 자바스크립트와 거의 동일한 비동기 모델을 따릅니다.

## 4. 리턴 타입 힌트와 NULL 처리 (Optional vs List)

### 인터페이스에서 리턴값이 없을 때(NULL)의 처리는 어떻게 정의되나요?
**배경**: `ItemRepository` 인터페이스의 `pass`만 있는 메서드 정의를 보고, 리턴값의 기본 설정(Null인지 빈 배열인지)을 어떻게 알 수 있는지 질문했습니다.

**타입 힌트의 약속 (Contract)**:
구현체는 인터페이스에 정의된 타입 힌트의 관례를 따릅니다.

1.  **`-> List[Item]` (목록 조회)**
    *   데이터가 없으면 **빈 리스트 `[]`**를 반환합니다. 절대 `None`(null)을 반환하지 않습니다.
2.  **`-> Optional[Item]` (단건 조회)**
    *   데이터가 없으면 **`None` (null)**을 반환합니다.

### Optional 반환 시 매번 NULL 체크를 해야 하나요?
**배경**: `Optional`로 인해 호출하는 쪽에서 매번 `if item is None` 체크를 해야 하는 번거로움에 대해 문의했습니다.

**패턴과 해법**:
1.  **Repository의 역할**: "데이터가 없다"는 사실을 있는 그대로 전달(`None`)하는 것이 정직한 구현입니다.
2.  **Service/API 계층의 역할**: 비즈니스 로직에 따라 `None`을 에러로 처리할지, 새로운 생성 로직으로 연결할지 결정합니다.
3.  **개선 패턴**:
    *   API 라우터에서 `if not item: raise HTTPException(...)`으로 처리하거나,
    *   서비스 계층에 `get_or_404` 같은 헬퍼 메서드를 만들어 에러 처리를 중앙화하여 코드를 간결하게 만들 수 있습니다.

## 5. 클린 아키텍처의 레이어 분리와 의존성 방향

### API 파일이 모든 것을 import 하는데, 정말 독립적인가요?
**배경**: `api/v1/items.py` 파일이 도메인, 인프라, 서비스를 모두 import 하고 있어 레이어 분리가 제대로 된 것인지 의문을 가졌습니다.

**핵심 구조 (Composition Root)**:
`api/v1/items.py`는 단순한 컨트롤러가 아니라, **애플리케이션의 진입점(Entry Point)이자 조립 공장** 역할을 겸하고 있습니다.

*   **Service의 청정성**: 핵심인 `ItemService` 코드는 `Infrastructure`를 import 하지 않습니다. 오직 `Domain(Interface)`만 바라봅니다.
*   **API의 역할**: API 라우터는 요청이 들어오면 `PostgresItemRepository`(부품)를 생성해서 `ItemService`에 끼워주는(주입, Injection) 역할을 수행합니다. 따라서 두 레이어를 모두 알아야 합니다.
*   의존성 방향은 모두 **바깥에서 안쪽(Domain)**을 향하고 있으므로 클린 아키텍처 원칙을 준수하고 있습니다.

### 인프라스트럭처가 왜 '가장 바깥' 레이어인가요?
**배경**: 실행 흐름(Call flow)상 API -> Service -> Infrastructure(DB 조회) 순서로 호출되는데, 왜 다이어그램에서는 Infrastructure가 가장 바깥에 위치하는지 이해하기 어려워했습니다.

**제어 흐름 vs 의존성 흐름 (DIP)**:
이 부분은 **의존성 역전 원칙(Dependency Inversion Principle)**의 핵심입니다.

1.  **제어 흐름 (실행 순서)**: `Service`가 데이터를 얻기 위해 `Repository`를 호출하는 것이 맞습니다. (Service -> Infra)
2.  **의존성 흐름 (소스코드 의존)**:
    *   `Service`는 구체적인 DB(Postgres, MySQL 등)를 알면 안 됩니다. 대신 "데이터를 가져오는 규칙(Interface)"인 주문서만 정의합니다.
    *   `Infrastructure`는 이 주문서(Interface)를 보고 구현체를 만듭니다. 즉, 인프라가 서비스의 규칙에 **의존**하게 됩니다. (Infra -> Service)
3.  **결론**:
    *   인프라스트럭처는 언제든 교체 가능한(Pluggable) **부품(플러그인)**과 같습니다.
    *   핵심 비즈니스 로직(Service/Domain)을 보호하기 위해, 변하기 쉬운 기술적 세부 사항(DB, 프레임워크)을 가장 바깥쪽 레이어로 밀어내는 것입니다.
